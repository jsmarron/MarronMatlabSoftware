function outstruct = DIVASDoubJointSM(mX,mY,paramstruct) 
% DIVAS Doubly Joint version
%     For matrices with both rows (scores) and columns (loadings) 
%     that correspond, does doubly joint (then other) decompositions
%     in an iterative fashion, stopping when there seems to be no 
%     remaining signal (or at a pre-specified number of steps)
%
%
% Inputs:
%   mX          - d x n matrix of X data
%                     Recommend both row and column recentering first
%
%   mY          - d x n matrix of Y data
%                     with corresponding rows and columns
%                     Recommend both row and column recentering first
%
%   paramstruct - a Matlab structure of input parameters
%                    Use: "help struct" and "help datatypes" to
%                         learn about these.
%                    Create one, using commands of the form:
%
%       paramstruct = struct('field1',values1, ...
%                            'field2',values2, ...
%                            'field3',values3) ;
%
%                          where any of the following can be used,
%                          these are optional, misspecified values
%                          revert to defaults
%
%                    Version for easy copying and modification:
%     paramstruct = struct('',, ...
%                          '',, ...
%                          '',) ;
%
%    fields            values
%
%    imptype          implementation type:
%                          1 - original greedy implementation
%                                  from DoublyJointToy8.m
%                          2 - QZ based implementation
%                                  from DoublyJointToy9.m
%    
%    iScaleStand      indicator for Scale Standardization 
%                          0 - Do not Scale Standardize
%                                  In this case, each data block should have
%                                  overall noise standard deviation 1
%                          1 - (default) Estimate overall standard 
%                                  deviation for each block using 
%                                  TriME, and rescale each
%
%    nThreshSim       number of simulations to find thresholds
%                          0 - No simulation, use crude Marcenko-Pastur bounds
%                                  (these tend to be too permissive)
%                          n - Number of simulations to compute thresholds,
%                                  (default 1000)
%
%    vthresh          vector of thresholds for singular values, 
%                          assuming N(0,1) scaling  (empty default)
%                          Suggest getting these as 
%                              outstruct.vthresh
%                          from previous run of DIVASDoubJointSM
%                          Only has effect for nThreshSim = 0 
%
%    nmaxstep         maximum number of steps (default of 10)
%
%    iDiagPlot        0  Make no diagnostic plots (just compute output)
%                     1  (default) Make diagnostic plots, mostly heatmaps
%
%    DiagPlotStr      String for saving output plots
%                         (leave empty for default of no plot save)
%
%    savetype         indicator of output file type:
%                          1 - (default)  Matlab figure file (.fig)
%                          2 - (.png)  raster graphics
%                          3 - (.pdf)  vector graphics
%                          4 - (.eps)  Color vector 
%                                      (use when icolor is not 0)
%                          5 - (.eps)  Black and White vector 
%                                      (use when icolor = 0)
%                          6 - (.jpg)  raster
%                          7 - (.svg)  vector    
%
%    iscreenwrite     0  (default)  no screen writes
%                     1  write to screen to show progress
%
%
% Outputs:
%
%   outstruct   - a Matlab structure of results
%               
%
%   Graphics in new figures when iDiagPlot = 1
%   When DiagPlotStr exists, generate output files, 
%       as indicated by savetype
%
% 
% Assumes path can find functions:
%    modeDfitSM
%    modeSUfitSM
%    modeSVfitSM
%    modeIfitSM
%    TriME
%

%    Copyright (c) J. S. Marron 2026


%  First set all parameters to defaults
%
imptype = 1 ;
iScaleStand = 1 ;
nThreshSim = 1000 ;
vthresh = [] ;
nmaxstep = 10 ;
iDiagPlot = 1 ;
DiagPlotStr = [] ;
savetype = 1 ;
iscreenwrite = 0 ;

%  Now update parameters as specified,
%  by parameter structure (if it is used)
%
if nargin > 2   %  then paramstruct is an argument

  if isfield(paramstruct,'imptype')    %  then change to input value
    imptype = paramstruct.imptype ;
  end

  if isfield(paramstruct,'iScaleStand')    %  then change to input value
    iScaleStand = paramstruct.iScaleStand ;
  end

  if isfield(paramstruct,'nThreshSim')    %  then change to input value
    nThreshSim = paramstruct.nThreshSim ;
  end

  if isfield(paramstruct,'vthresh')    %  then change to input value
    vthresh = paramstruct.vthresh ;
  end

  if isfield(paramstruct,'nmaxstep')    %  then change to input value
    nmaxstep = paramstruct.nmaxstep ;
  end

  if isfield(paramstruct,'iDiagPlot')    %  then change to input value
    iDiagPlot = paramstruct.iDiagPlot ;
  end

  if isfield(paramstruct,'DiagPlotStr')    %  then change to input value
    DiagPlotStr = paramstruct.DiagPlotStr ;
  end

  if isfield(paramstruct,'savetype')    %  then change to input value
    savetype = paramstruct.savetype ;
  end

%{
  if isfield(paramstruct,'')    %  then change to input value
     = paramstruct. ;
  end
%}

  if isfield(paramstruct,'iscreenwrite')    %  then change to input value
    iscreenwrite = paramstruct.iscreenwrite ;
  end

end    %  of resetting of input parameters


if iscreenwrite == 1 
  disp('Running function DIVASDoubJointSM.m') ;
  disp(' ') ;
end


%  Check input data
%
d = size(mX,1) ;
         %  number of rows of input mX
n = size(mX,2) ;
         %  number of columns of input mX
if  (size(mY,1) ~= d)  |  (size(mY,2) ~= n)
  disp('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!') ;
  disp('!!!   Error from DIVASDoubJointSM.m:   !!!') ;
  disp('!!!   Inputs mX and mY must have       !!!') ;
  disp('!!!   the same dimensions              !!!') ;
  disp('!!!   Terminating execution            !!!') ;
  disp('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!') ;
  outstruct = 'Not defined yet' ;
  return ;
end


%  Estimate noise levels for each input and normalize
%
beta = min(d,n) / max(d,n) ;
    %  Marcenko Pasturn parameter
[mU_X,dmlam_X,mV_X] = svd(mX,'econ') ;
[mU_Y,dmlam_Y,mV_Y] = svd(mY,'econ') ;
    %  minimal rank versions of svd
    %  Organized as o. n. Basis matrices, and 
    %  diagonal matrix of singular values
vlam_X = diag(dmlam_X) ;
vlam_Y = diag(dmlam_Y) ;
    %  vectors of singular values
if iScaleStand == 1     %  Use TriME standardization 

  %  Calculate Emma Mitchell's estimate of noise standard deviation
  %  Described in her PhD dissertation:
  %      "STATISTICAL METHODS FOR GENOMIC DATA ANALYSIS"
  %
  c = min(d,n) / max(d,n) ;
  SigEstX = TriME(c,vlam_X/sqrt(max(d,n)),1,'/temp',0.01,0,0.25,false) ;
  SigEstY = TriME(c,vlam_Y/sqrt(max(d,n)),1,'/temp',0.01,0,0.25,false) ;
      %  1 and '/temp' not relevant, since don't make graphics
      %  Other parameters are defaults suggested in dissertation:
      %      alpha1 = 0.01 
      %      alpha2 = 0
      %      omega = 0.25
      %  sve = false turns off graphics

SigEstX
SigEstY

  if SigEstX == 0
    disp('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!') ;
    disp('!!!   Error from DIVASDoubJointSM.m                !!!') ;
    disp('!!!   Unable to estimate X background noise level  !!!') ;
    disp('!!!   Basic assumption seems violated              !!!') ;
    disp('!!!   Terminating with empty return                !!!') ;
    disp('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!') ;
    outstruct = [] ;
    return 
  elseif SigEstY == 0
    disp('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!') ;
    disp('!!!   Error from DIVASDoubJointSM.m                !!!') ;
    disp('!!!   Unable to estimate Y background noise level  !!!') ;
    disp('!!!   Basic assumption seems violated              !!!') ;
    disp('!!!   Terminating with empty return                !!!') ;
    disp('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!') ;
    outstruct = [] ;
    return 
  else
    mXs = mX / SigEstX ;
    mYs = mY / SigEstY ;
        %  Normalize so noise part of each block has overall SD 1
  end


else     %  Proceed with original data

  mXs = mX ;
  mYs = mY ;

end 


if imptype == 1     %  Original greedy implementation
                    %      from DoublyJointToy8.m

  %  Get thresholds
  %
  if nThreshSim == 0     %  Use crude Marcenko-Pastur bounds
                         %      from DoublyJointToy7

    threshXnY = sqrt(min(d,n)) * (1 + sqrt(max(d,n) / min(d,n))) ;
    threshU = sqrt(2 * n) * (1 + sqrt(d / (2 * n))) ;
    threshV = sqrt(2 * d) * (1 + sqrt(n / (2 * d))) ;

    if iscreenwrite == 1 
      disp('Using naive thresholds') ;
      disp(' ') ;
    end

  else    %  Compute simulated thresholds

threshXnY = sqrt(min(d,n)) * (1 + sqrt(max(d,n) / min(d,n))) ;
threshU = sqrt(2 * n) * (1 + sqrt(d / (2 * n))) ;
threshV = sqrt(2 * d) * (1 + sqrt(n / (2 * d))) ;
disp('Simulated thresholds not yet implemented') ;
disp('Using naive thresholds instead') ;

  end     %  of threshold sim if-block


  %  Initialize running matrices and cell arrays
  %
  mE_X = mXs ;
  mE_Y = mYs ;
      %  Matrices of remaining variation 
      %      (starting with everything as "noise"
      %       and iteratively extracting signal modes)
      %  Using A + E (signal + noise) notation from DIVAS
  mA_X = zeros(d,n) ;
  mA_Y = zeros(d,n) ;
      %  Cumulative Signal Matrices
      %  Will update, with X = A_X + E_X and Y = A_Y + E_Y at each step
  nmodes = 0 ;
      %  number of modes of variation found so far
  caXmodes = {} ;
  caYmodes = {} ;
      %  cell arrays of significant modes of variation
  iDJmodefig = 0 ;
  iSUJmodefig = 0 ;
  iSVJmodefig = 0 ;
  iImodefig = 0 ;
      %  indices of figures already made for each mode type

  %  Compute X and Y SVDs
  %
  [mU_X,dmlam_X,mV_X] = svd(mE_X,'econ') ;
  [mU_Y,dmlam_Y,mV_Y] = svd(mE_Y,'econ') ;
      %  minimal rank versions of svd
      %  Organized as o. n. Basis matrices 
      %  diagonal matrix of singular values
  vlam_X = diag(dmlam_X) ;
  vlam_Y = diag(dmlam_Y) ;
      %  vectors of singular values

  %  Find Separate Blocks Initial Ranks
  %
  vflag_X = (vlam_X > threshXnY) ;
  [~,r_X] = min(vflag_X) ;    %  index of first 0
  r_X = r_X - 1 ;    %  index of last 1 (0 if none)
  vflag_Y = (vlam_Y > threshXnY) ;
  [~,r_Y] = min(vflag_Y) ;    %  index of first 0
  r_Y = r_Y - 1 ;    %  index of last 1 (0 if none)
  if iscreenwrite == 1
    disp(' ') ;
    disp(['Separate Block Filtered rank of X is ' num2str(r_X)]) ;
    disp(['Separate Block Filtered rank of Y is ' num2str(r_Y)]) ;
  end

  %  Define number of decomposition steps to consider
  %
  nstep = r_X + r_Y ;
  if iscreenwrite == 1
    disp(' ') ;
    disp(['Number of steps to consider (max filtered rank) = ' ...
               num2str(nstep)]) ;
    if nstep > nmaxstep
      disp(['But will only calculate input maxnstep = ' ...
               num2str(nmaxstep) ' steps']) ;
      nstep = nmaxstep ;
    end
  else
    if nstep > nmaxstep
      nstep = nmaxstep ;
    end
  end

  if iDiagPlot == 1 
    %  Start rank diagnostic plot
    %
    fh1 = figure('WindowStyle','normal') ;
    clf ;
    set(fh1,'Position',[100 100 1000 600]) ;
    lam_max = max([vlam_X; vlam_Y; threshV]) ;
    vax = [0 (n + 1) 0 (1.05 * lam_max)] ;
        %  biggest of singular values

    subplot(2,3,1) ;    %  X only
      plot((1:length(vlam_X))',vlam_X,'ko-') ;
      xlabel('k') ;
      ylabel('lambda X') ;
      title(['X Singular Values']) ;
      axis(vax) ;
      hold on ;
        plot([0; (n+1)],[threshXnY; threshXnY],'r-') ;
        text(vax(1) + 0.6 * (vax(2) - vax(1)), ...
             vax(3) + 0.9 * (vax(4) - vax(3)), ...
             ['r_X = ' num2str(r_X)]) ;
      hold off ;

    subplot(2,3,4) ;    %  Y only
      plot((1:length(vlam_Y))',vlam_Y,'ko-') ;
      xlabel('k') ;
      ylabel('lambda Y') ;
      title(['Y Singular Values']) ;
      axis(vax) ;
      hold on ;
        plot([0; (n+1)],[threshXnY; threshXnY],'r-') ;
        text(vax(1) + 0.6 * (vax(2) - vax(1)), ...
             vax(3) + 0.9 * (vax(4) - vax(3)), ...
             ['r_Y = ' num2str(r_Y)]) ;
      hold off ;
  end     %  of iDiagPlot if-block


  %  Main loop stepping through components
  %
  for istep = 1:nstep

    if iscreenwrite == 1
      disp(' ') ;
      disp(' ') ;
      disp(['working on step ' num2str(istep) ' of ' num2str(nstep)]) ;
    end 

    if istep > 1    %  recompute separate block ranks

      [mU_X,dmlam_X,mV_X] = svd(mE_X,'econ') ;
      [mU_Y,dmlam_Y,mV_Y] = svd(mE_Y,'econ') ;
      vlam_X = diag(dmlam_X) ;
      vlam_Y = diag(dmlam_Y) ;
          %  vectors of singular values
      vflag_X = (vlam_X > threshXnY) ;
      [~,r_X] = min(vflag_X) ;    %  index of first 0
      r_X = r_X - 1 ;    %  index of last 1 (0 if none)
      vflag_Y = (vlam_Y > threshXnY) ;
      [~,r_Y] = min(vflag_Y) ;    %  index of first 0
      r_Y = r_Y - 1 ;    %  index of last 1 (0 if none)

    end     %  of istep > 1 if-block

    %  Compute stacked SVDs
    %
    [mU_U,dmlam_U,mV_U] = svd([mE_X mE_Y],'econ') ;
    [mU_V,dmlam_V,mV_V] = svd([mE_X; mE_Y],'econ') ;
        %  minimal rank versions of svd
    vlam_U = diag(dmlam_U) ;
    vlam_V = diag(dmlam_V) ;

    %  Find Stacked Initial Ranks
    %
    vflag_U = (vlam_U > threshU) ;
%vlam_U'
%threshU
    [~,r_U] = min(vflag_U) ;    %  index of first 0
    r_U = r_U - 1 ;    %  index of last 1 (0 if none)
    vflag_V = (vlam_V > threshV) ;
    [~,r_V] = min(vflag_V) ;    %  index of first 0
    r_V = r_V - 1 ;    %  index of last 1 (0 if none)
    if iscreenwrite == 1
      disp(' ') ;
      disp(['  Horizontally Stacked rank of U is ' num2str(r_U)]) ;
      disp(['  Vertically Stacked rank of V is ' num2str(r_V)]) ;
    end

    if istep == 1     %  Update SVD diagnostic plot

      if iDiagPlot == 1 

        lam_max = max([lam_max; vlam_U; vlam_V; threshU; threshV]) ;
        vax = [0 (n + 1) 0 (1.05 * lam_max)] ;

        subplot(2,3,2) ;    %  Horizontal Stack
          plot((1:length(vlam_U))',vlam_U,'ko-') ;
          xlabel('k') ;
          ylabel('lambda U') ;
          title('Horizontal Stack Singular Values') ;
          axis(vax) ;
          hold on ;
            plot([0; (n+1)],[threshU; threshU],'r-') ;
            text(vax(1) + 0.6 * (vax(2) - vax(1)), ...
                 vax(3) + 0.9 * (vax(4) - vax(3)), ...
                 ['r_U = ' num2str(r_U)]) ;
          hold off ;

        subplot(2,3,5) ;    %  Vertical Stack
          plot((1:length(vlam_V))',vlam_V,'ko-') ;
          xlabel('k') ;
          ylabel('lambda V') ;
          title('Vertical Stack Singular Values') ;
          axis(vax) ;
          hold on ;
            plot([0; (n+1)],[threshV; threshV],'r-') ;
            text(vax(1) + 0.6 * (vax(2) - vax(1)), ...
                 vax(3) + 0.9 * (vax(4) - vax(3)), ...
                 ['r_V = ' num2str(r_V)]) ;
          hold off ;

      end    %  of iDiagPlot if-block

    end    %  of istep 1 if-block


    if r_U > 0     %  Then have U Union directions to work with

      %  Project each of X and Y onto U_union space
      %
      S_UX = mU_U(:,1:r_U)' * mE_X ;
      S_UY = mU_U(:,1:r_U)' * mE_Y ;
          %  r_U x n Inner products (hence scores)
          %  of X & Y with basis matrix of U space
      Xcup_UX = mU_U(:,1:r_U) * S_UX ;
      Ycup_UY = mU_U(:,1:r_U) * S_UY ;
          %  d x n representations of generated subspaces`

      [B_UX,dmlam_UX,~] = svd(Xcup_UX,'econ') ;
      vlam_UX = diag(dmlam_UX) ;
      vflag_BUX = (vlam_UX > threshXnY) ;
      [~,r_BUX] = min(vflag_BUX) ;    %  index of first 0
      r_BUX = r_BUX - 1 ;    %  index of last 1 (0 if none)
      B_UX = B_UX(:,1:r_BUX) ;
          %  Basis matrix of subspace generated by projection of X on U space

      [B_UY,dmlam_UY,~] = svd(Ycup_UY,'econ') ;
      vlam_UY = diag(dmlam_UY) ;
      vflag_BUY = (vlam_UY > threshXnY) ;
      [~,r_BUY] = min(vflag_BUY) ;    %  index of first 0
      r_BUY = r_BUY - 1 ;    %  index of last 1 (0 if none)
      B_UY = B_UY(:,1:r_BUY) ;
          %  Basis matrix of subspace generated by projection of Y on U space

      if  r_BUX > 0  &  r_BUY > 0     %  may have U joint directions
                                      %  Look further by SVD of sum
                                      %  of projection matrices

        P_UX = B_UX * B_UX' ; 
        P_UY = B_UY * B_UY' ; 
            %  Projection matrices onto those subspaces
            %  Simpler form since B_UX and B_UY are orthonormal basis matrices
        [mU_UJ,dmlam_UJ,mV_UJ] = svd(P_UX + P_UY,'econ') ;
        vlam_UJ = diag(dmlam_UJ) ;

        %  Find basis matrix for Union U Joint subspace
        %
        vflag_UJ = (vlam_UJ > 1.5) ;

        [~,r_UJ] = min(vflag_UJ) ;    %  index of first 0
        r_UJ = r_UJ - 1 ;    %  index of last 1 (0 if none)

        if r_UJ > 0     %  Have a UJ subspace (could be doubly or singly joint)

          B_UJoint = mU_UJ(:,1:r_UJ) ;
              %  Basis matrix of U subspace (Doubly or Singly)

          %  Project X and Y on U joint space
          %
          S_UJX = B_UJoint' * mE_X ;
          S_UJY = B_UJoint' * mE_Y ;
          Xcup_UJX = B_UJoint * S_UJX ;
          Ycup_UJY = B_UJoint * S_UJY ;
              %  d x n representations of generated subspaces`

          %  Find Corresponding V space for X
          %
          [~,dmUJXlam,V_UJX] = svd(Xcup_UJX,'econ') ;
          vUJXlam = diag(dmUJXlam) ;
          vflag_UJX = (vUJXlam > threshXnY) ;
              %  May be able to improve this threshold
          [~,r_UJX] = min(vflag_UJX) ;    %  index of first 0
          r_UJX = r_UJX - 1 ;    %  index of last 1 (0 if none)
          V_UJX = V_UJX(:,1:r_UJX) ;
              %  Basis natrix of R^n (i.e. v) subspace generated by 
              %      projection of X on Joint U space

          %  Find Corresponding V space for Y
          %
          [~,dmUJYlam,V_UJY] = svd(Ycup_UJY,'econ') ;
          vUJYlam = diag(dmUJYlam) ;
          vflag_UJY = (vUJYlam > threshXnY) ;
              %  May be able to improve this threshold
          [~,r_UJY] = min(vflag_UJY) ;    %  index of first 0
          r_UJY = r_UJY - 1 ;    %  index of last 1 (0 if none)
          V_UJY = V_UJY(:,1:r_UJY) ;
              %  Basis matrix of R^n (i.e. v) subspace generated by 
              %      projection of Y on Joint U space

          %  Find U driven candidate for Doubly Joint mode
          %      using Principal Angle Analysis
          [mc_UPAX,dmlam_UPA,mc_UPAY] = svd(V_UJX' * V_UJY,'econ') ;
          vlam_UPA = diag(dmlam_UPA) ;
          vc_UPAX = mc_UPAX(:,1) ;
          vc_UPAY = mc_UPAY(:,1) ;
          if iscreenwrite == 1
            disp(['    U driven Principal Angles = ' num2str(acosd(vlam_UPA'))]) ;
          end 
          angU = acosd(vlam_UPA(1)) ;

        end     %  of have UJ subspace if-block
                %      (if r_UJ > 0)

      else

        r_UJ = 0 ;    %  No U Joint modes
        vlam_UJ = zeros(d,1) ;
            %  put all zeros, to show no Horizontal concatenated mode

      end     %  of have both projections on U space
              %      (if  r_BUX > 0  &  r_BUY > 0)

      if istep == 1     %  Add to SVD diagnostic plots

%{
        if iscreenwrite == 1
          disp(['  Rank of Projection of X on U space, r_UX = ' num2str(r_BUX)]) ;
          disp(['  Rank of Projection of Y on U space, r_UY = ' num2str(r_BUY)]) ;
          disp(['  U space Joint rank = ' num2str(r_UJ)]) ;
        end
%}

        if iDiagPlot == 1 
          %  Add to diagnostic graphic
          %
          vaxU = [0 (n + 1) 0 2.1] ;
          subplot(2,3,3) ;    %  U Concatenation
            plot((1:length(vlam_UJ))',vlam_UJ,'ko-') ;
            xlabel('k') ;
            ylabel('lambda UJ') ;
            title('U Joint Concatenated Singular Values') ;
            axis(vaxU) ;
            hold on ;
              plot([0; (n+1)],[1.5; 1.5],'r-') ;
              text(vaxU(1) + 0.6 * (vaxU(2) - vax(1)), ...
                   vaxU(3) + 0.9 * (vaxU(4) - vax(3)), ...
                   ['r_{UJ} = ' num2str(r_UJ)]) ;
            hold off ;
        end     %  of iDiagPlot if-block

      end    %  of istep 1 if-block


    else

        r_UJ = 0 ;    %  No U Joint modes

    end     %  if-block for having U Union directions to work with
            %       (if r_U > 0)


    if r_V > 0     %  Then have V Union directions to work with

      %  Project each of X and Y onto V_union space
      %
      L_VX = mE_X * mV_V(:,1:r_V) ;
      L_VY = mE_Y * mV_V(:,1:r_V) ;
          %  r_V x n Inner products (hence loadings)
          %  of X & Y with basis matrix of V space
      Xcup_VX = L_VX * mV_V(:,1:r_V)' ;
      Ycup_VY = L_VY * mV_V(:,1:r_V)' ;
          %  d x n representations of generated subspaces`

      [~,dmlam_VX,B_VX] = svd(Xcup_VX,'econ') ;
      vlam_VX = diag(dmlam_VX) ;
      vflag_BVX = (vlam_VX > threshXnY) ;
      [~,r_BVX] = min(vflag_BVX) ;    %  index of first 0
      r_BVX = r_BVX - 1 ;    %  index of last 1 (0 if none)
      B_VX = B_VX(:,1:r_BVX) ;
          %  Basis matrix of subspace generated by projection of X on V space

      [~,dmlam_VY,B_VY] = svd(Ycup_VY,'econ') ;
      vlam_VY = diag(dmlam_VY) ;
      vflag_BVY = (vlam_VY > threshXnY) ;
      [~,r_BVY] = min(vflag_BVY) ;    %  index of first 0
      r_BVY = r_BVY - 1 ;    %  index of last 1 (0 if none)
      B_VY = B_VY(:,1:r_BVY) ;
          %  Basis matrix of subspace generated by projection of Y on V space

      if  r_BVX > 0  &  r_BVY > 0     %  may have V joint directions
                                      %  Look further by SVD of sum
                                      %  of projection matrices
   
        P_VX = B_VX * B_VX' ; 
        P_VY = B_VY * B_VY' ; 
            %  Projection matrices onto those subspaces
            %  Simpler form since B_UX and B_UY are orthonormal basis matrices
        [mU_VJ,dmlam_VJ,mV_VJ] = svd(P_VX + P_VY,'econ') ;
        vlam_VJ = diag(dmlam_VJ) ;

        %  Find basis matrix for Union U Joint subspace
        %
        vflag_VJ = (vlam_VJ > 1.5) ;
        [~,r_VJ] = min(vflag_VJ) ;    %  index of first 0
        r_VJ = r_VJ - 1 ;    %  index of last 1 (0 if none)

        if r_VJ > 0     %  Have a VJ subspace

          B_VJoint = mV_VJ(:,1:r_VJ) ;
              %  Basis matrix of subspace (Doubly or Singly)

          %  Project X and Y on V joint space
          %
          L_VJX = mE_X * B_VJoint ;
          L_VJY = mE_Y * B_VJoint ;
          Xcup_VJX = L_VJX * B_VJoint' ;
          Ycup_VJY = L_VJY * B_VJoint' ;
              %  d x n representations of generated subspaces`

          %  Find Corresponding U space for X
          %
          [U_VJX,dmVJXlam,~] = svd(Xcup_VJX,'econ') ;
          vVJXlam = diag(dmVJXlam) ;
          vflag_VJX = (vVJXlam > threshXnY) ;
              %  May be able to improve this threshold
          [~,r_VJX] = min(vflag_VJX) ;    %  index of first 0
          r_VJX = r_VJX - 1 ;    %  index of last 1 (0 if none)
          U_VJX = U_VJX(:,1:r_VJX) ;
              %  Basis natrix of R^d (i.e. u) subspace generated by 
              %      projection of X on Joint V space

          %  Find Corresponding U space for Y
          %
          [U_VJY,dmVJYlam,~] = svd(Ycup_VJY,'econ') ;
          vVJYlam = diag(dmVJYlam) ;
          vflag_VJY = (vVJYlam > threshXnY) ;
              %  May be able to improve this threshold
          [~,r_VJY] = min(vflag_VJY) ;    %  index of first 0
          r_VJY = r_VJY - 1 ;    %  index of last 1 (0 if none)
          U_VJY = U_VJY(:,1:r_VJY) ;
              %  Basis matrix of R^d (i.e. u) subspace generated by 
              %      projection of Y on Joint V space

          %  Find V driven candidate for Doubly Joint mode
          %      using Principal Angle Analysis
          [mc_VPAX,dmlam_VPA,mc_VPAY] = svd(U_VJX' * U_VJY,'econ') ;
          vlam_VPA = diag(dmlam_VPA) ;
          vc_VPAX = mc_VPAX(:,1) ;
          vc_VPAY = mc_VPAY(:,1) ;
          if iscreenwrite == 1
            disp(['    V driven Principal Angles = ' num2str(acosd(vlam_VPA'))]) ;
          end
          angV = acosd(vlam_VPA(1)) ;

        end     %  of have UJ subspace if-block
                %      (if r_VJ > 0)



      else ;

        r_VJ = 0 ;    %  No V Joint modes
        vlam_VJ = zeros(d,1) ;
            %  put all zeros, to show no significant vertical concatenated mode

      end     %  of have both projections on U space
              %      (if  r_BVX > 0  &  r_BVY > 0)

      if istep == 1     %  Add to SVD diagnostic plots

%{
        if iscreenwrite == 1
          disp(['  Rank of Projection of X on V space, r_VX = ' num2str(r_BVX)]) ;
          disp(['  Rank of Projection of Y on V space, r_VY = ' num2str(r_BVY)]) ;
          disp(['  V space Joint rank = ' num2str(r_VJ)]) ;
        end
%}

        if iDiagPlot == 1 
          %  Add to diagnostic graphic
          %
          vaxV = [0 (n + 1) 0 2.1] ;
          subplot(2,3,6) ;    %  V  Concatenation
            plot((1:length(vlam_VJ))',vlam_VJ,'ko-') ;
            xlabel('k') ;
            ylabel('lambda VJ') ;
            title('V Joint Concatenated Singular Values') ;
            axis(vaxV) ;
            hold on ;
              plot([0; (n+1)],[1.5; 1.5],'r-') ;
              text(vaxV(1) + 0.6 * (vaxV(2) - vax(1)), ...
                   vaxV(3) + 0.9 * (vaxV(4) - vax(3)), ...
                   ['r_{VJ} = ' num2str(r_VJ)]) ;
            hold off ;
        end     %  of iDiagPlot if-block

      end    %  of istep 1 if-block


    else ;

      r_VJ = 0 ;    %  No V Joint modes

    end     %  if-block for having V Union directions to work with
            %       (if r_V > 0)

    flagbothjoint =  (r_UJ > 0)  &  (r_VJ > 0) ;
            %  Have both U and V Joint modes
            %  so there may be a doubly joint mode
    if  flagbothjoint
      if iscreenwrite == 1
        disp('  Have both U and V Joint modes') ;
      end

      minang = min(angU,angV) ;
      flagsmallang = (minang < 45) ;
      if flagsmallang     %  have a candidate for doubly joint mode

        if iscreenwrite == 1
          disp('    Have a small angle between U and V Joint modes') ;
        end

        if angU <= angV     %  Base doubly joint mode candidate on U-space

          vv_PAX = V_UJX * vc_UPAX ;
          vv_PAY = V_UJY * vc_UPAY ;
              %  Smallest angle linear combos
          vv_PAX = vv_PAX / norm(vv_PAX) ;
          vv_PAY = vv_PAY / norm(vv_PAY) ;
              %  make into direction (unit) vectors

          vu_PAX = mE_X * vv_PAX ;
          vu_PAY = mE_Y * vv_PAY ;
              %  Projections on X and Y
          vu_PAX = vu_PAX / norm(vu_PAX) ;
          vu_PAY = vu_PAY / norm(vu_PAY) ;
              %  make into direction (unit) vectors

        else     %  Base doubly joint mode candidate on V-space

          vu_PAX = U_VJX * vc_VPAX ;
          vu_PAY = U_VJY * vc_VPAY ;
              %  Smallest angle linear combos
          vu_PAX = vu_PAX / norm(vu_PAX) ;
          vu_PAY = vu_PAY / norm(vu_PAY) ;
              %  make into direction (unit) vectors

          vv_PAX = mE_X' * vu_PAX ;
          vv_PAY = mE_Y' * vu_PAY ;
              %  Projections on X and Y
          vv_PAX = vv_PAX / norm(vv_PAX) ;
          vv_PAY = vv_PAY / norm(vv_PAY) ;
              %  make into direction (unit) vectors

        end    %  of if-block for which base of doubly joint mode

        vu_DJ = vu_PAX + vu_PAY ;
        vv_DJ = vv_PAX + vv_PAY ;
            %  average directions
        vu_DJ = vu_DJ / norm(vu_DJ) ;
        vv_DJ = vv_DJ / norm(vv_DJ) ;
              %  make into direction (unit) vectors

        c_X = modeDfitSM(mE_X,vu_DJ,vv_DJ) ;
        c_Y = modeDfitSM(mE_Y,vu_DJ,vv_DJ) ;
            %  Coefficients of modes of variation

        flagDJsig = (abs(c_X) >= threshXnY) & (abs(c_Y) >= threshXnY) ;
            %  Have significant signal in both X and Y DJ components.
        if flagDJsig 
          imodetype = 1 ;    %  Make Doubly Joint Output plot
          if iscreenwrite == 1
            disp('  Found Doubly Joint Mode') ;
          end
        else
          if iscreenwrite == 1
            disp('  No Doubly Joint mode, since signal insignificant') ;
          end
        end ;

      end     %  of flagsmallang if-block


      if  (flagsmallang  &  ~flagDJsig)  |  ~flagsmallang
                 %  Either no small angle, or an insignificant signal
                 %  Compare spaces to choose a singly joint mode

        if iscreenwrite == 1
          disp('  Finding best Singly Joint mode') ;
        end

        if vlam_UJ(1) >= vlam_VJ(1)    %  Then use U driven Singly joint mode

          vu_SUJ = mU_UJ(:,1) ;
          imodetype = 2 ;    %  Make U Singly Joint Output plot

        else    %  Then use V driven Singly joint mode

          vv_SVJ = mV_VJ(:,1) ;
          imodetype = 3 ;    %  Make V Singly Joint Output plot

        end     %  of if-block choosing which singly joint mode to pursue

      end      %  of  either no small angle, or an insignificant signal  if-block


    else     %  Don't have both U and V spaces  (flagbothjoint = 0)

      if iscreenwrite == 1
        disp('  Did not have both U and V singly joint modes') ;
      end

      if  r_UJ > 0     %  Have only U Joint Space

        vu_SUJ = mU_UJ(:,1) ;
        imodetype = 2 ;    %  Make U Singly Joint Output plot

      elseif  r_VJ > 0     %  Have only V Joint Space

        vv_SVJ = mV_VJ(:,1) ;
        imodetype = 3 ;    %  Make V Singly Joint Output plot

      else     %  Have no joint space, try for individual modes

        if iscreenwrite == 1
          disp('  Did not find any Singly Joint mode of variation') ;
        end

        if max(r_X,r_Y) > 0     %  have an individual mode


          if vlam_X(1) >= vlam_Y(1)    %  Then use X individal mode

            mImode_X = vlam_X(1) * mU_X(:,1) * mV_X(:,1)' ;
                %  Individual X mode of variation
            imodetype = 4 ;    %  Make X Individual Output plot

          else    %  Then use y individal mode

            mImode_Y = vlam_Y(1) * mU_Y(:,1) * mV_Y(:,1)' ;
                %  Individual Y mode of variation
            imodetype = 5 ;    %  Make Y Individual Output plot

          end


        else     %  Have no individual mode

          if iscreenwrite == 1
            disp('  Did not find any Individual mode of variation') ;
          end
          imodetype = 0 ;

        end 


      end     %  of have only one or no Joint spaces if block


    end      %  of flagbothjoint if-block, for both U and V Joint modes
             %       (if  r_UJ > 0  &  r_VJ > 0)


    %  Construct this mode, save in outstruct, and update data matrices
    %
    if imodetype == 1     %  Found Doubly Joint Mode

      if iscreenwrite == 1
        disp('Found Doubly Joint Mode of Variation') ;
      end

      mDJmode_X = c_X * vu_DJ * vv_DJ' ;
      mDJmode_Y = c_Y * vu_DJ * vv_DJ' ;
          %  Doubly Joint modes of variation

      %  Update running quantities
      %
      mE_X = mE_X - mDJmode_X ;
      mE_Y = mE_Y - mDJmode_Y ;
      mA_X = mA_X + mDJmode_X ;
      mA_Y = mA_Y + mDJmode_Y ;
          %  Running matrices
      nmodes = nmodes + 1 ;
          %  number of modes of variation found so far
      caXmodes(nmodes,1) = {'D'} ;
      caXmodes(nmodes,2) = {c_X} ;
      caXmodes(nmodes,3) = {vu_DJ} ;
      caXmodes(nmodes,4) = {vv_DJ} ;
      caYmodes(nmodes,1) = {'D'} ;
      caYmodes(nmodes,2) = {c_Y} ;
      caYmodes(nmodes,3) = {vu_DJ} ;
      caYmodes(nmodes,4) = {vv_DJ} ;
          %  cell arrays of significant modes of variation


      if iDiagPlot == 1     %  Plot Doubly Joint Mode of variation
        
        iDJmodefig = iDJmodefig + 1 ;
        fh2 = figure('WindowStyle','normal') ;
        clf ;
        set(fh2,'Position',[100 100 1000 550]) ;

        subplot(1,2,1) ;
          titlestr = ['Block X, Doubly Joint Mode of Variation ' ...
                          num2str(iDJmodefig)] ;
          paramstruct = struct('icolor',2, ...
                               'icolordist',0, ...
                               'titlestr',titlestr) ;
          HeatMapSM(mDJmode_X,paramstruct) ;

        subplot(1,2,2) ;
          titlestr = ['Block Y, Doubly Joint Mode of Variation ' ...
                          num2str(iDJmodefig)] ;
          paramstruct = struct('icolor',2, ...
                               'icolordist',0, ...
                               'titlestr',titlestr) ;
          HeatMapSM(mDJmode_Y,paramstruct) ;

        if ~isempty(DiagPlotStr)
          savestr = [DiagPlotStr 'DJmode' num2str(iDJmodefig)] ;
          printSM(savestr,savetype) ;
        end 

      end     %  of iDiagPlot == 1  if-block


    elseif imodetype == 2     %  Found U Singly Joint Mode

      if iscreenwrite == 1
        disp('Found U Singly Mode of Variation') ;
      end ;

      [c_X,vv_SUJX] = modeSUfitSM(mE_X,vu_SUJ) ;
      [c_Y,vv_SUJY] = modeSUfitSM(mE_Y,vu_SUJ) ;
          %  Coefficients of modes of variation

      mSUJmode_X = c_X * vu_SUJ * vv_SUJX' ;
      mSUJmode_Y = c_Y * vu_SUJ * vv_SUJY' ;
          %  U Singly Joint modes of variation

      %  Update running quantities
      %
      mE_X = mE_X - mSUJmode_X ;
      mE_Y = mE_Y - mSUJmode_Y ;
      mA_X = mA_X + mSUJmode_X ;
      mA_Y = mA_Y + mSUJmode_Y ;
          %  Running matrices
      nmodes = nmodes + 1 ;
          %  number of modes of variation found so far
      caXmodes(nmodes,1) = {'SU'} ;
      caXmodes(nmodes,2) = {c_X} ;
      caXmodes(nmodes,3) = {vu_SUJ} ;
      caXmodes(nmodes,4) = {vv_SUJX} ;
      caYmodes(nmodes,1) = {'SU'} ;
      caYmodes(nmodes,2) = {c_Y} ;
      caYmodes(nmodes,3) = {vu_SUJ} ;
      caYmodes(nmodes,4) = {vv_SUJY} ;
          %  cell arrays of significant modes of variation

      if iDiagPlot == 1     %  Plot U Singly Joint Mode of  variation

        iSUJmodefig = iSUJmodefig + 1 ;
        fh3 = figure('WindowStyle','normal') ;
        clf ;
        set(fh3,'Position',[100 100 1000 550]) ;

        subplot(1,2,1) ;
          titlestr = ['Block X, U Singly Joint Mode of Variation ' ...
                           num2str(iSUJmodefig)] ;
          paramstruct = struct('icolor',2, ...
                               'icolordist',0, ...
                               'titlestr',titlestr) ;
          HeatMapSM(mSUJmode_X,paramstruct) ;

        subplot(1,2,2) ;
          titlestr = ['Block Y, U Singly Joint Mode of Variation ' ...
                           num2str(iSUJmodefig)] ;
          paramstruct = struct('icolor',2, ...
                               'icolordist',0, ...
                               'titlestr',titlestr) ;
          HeatMapSM(mSUJmode_Y,paramstruct) ;

        if ~isempty(DiagPlotStr)
          savestr = [DiagPlotStr 'SUJmode' num2str(iSUJmodefig)] ;
          printSM(savestr,savetype) ;
        end

      end     %  of iDiagPlot == 1  if-block


    elseif imodetype == 3     %  Found V Singly Joint Mode

      if iscreenwrite == 1
        disp('Found V Singly Mode of Variation') ;
      end

      [c_X,vu_SVJX] = modeSVfitSM(mE_X,vv_SVJ) ;
      [c_Y,vu_SVJY] = modeSVfitSM(mE_Y,vv_SVJ) ;
          %  Coefficients of modes of variation

      mSVJmode_X = c_X * vu_SVJX * vv_SVJ' ;
      mSVJmode_Y = c_Y * vu_SVJY * vv_SVJ' ;
          %  V Singly Joint modes of variation

      %  Update running quantities
      %
      mE_X = mE_X - mSVJmode_X ;
      mE_Y = mE_Y - mSVJmode_Y ;
      mA_X = mA_X + mSVJmode_X ;
      mA_Y = mA_Y + mSVJmode_Y ;
          %  Running matrices
      nmodes = nmodes + 1 ;
          %  number of modes of variation found so far
      caXmodes(nmodes,1) = {'SV'} ;
      caXmodes(nmodes,2) = {c_X} ;
      caXmodes(nmodes,3) = {vu_SVJX} ;
      caXmodes(nmodes,4) = {vv_SVJ} ;
      caYmodes(nmodes,1) = {'SV'} ;
      caYmodes(nmodes,2) = {c_Y} ;
      caYmodes(nmodes,3) = {vu_SVJY} ;
      caYmodes(nmodes,4) = {vv_SVJ} ;
          %  cell arrays of significant modes of variation


      if iDiagPlot == 1     %  Plot V Singly Joint Mode of variation

        iSVJmodefig = iSVJmodefig + 1 ;
        fh4 = figure('WindowStyle','normal') ;
        clf ;
        set(fh4,'Position',[100 100 1000 550]) ;

        subplot(1,2,1) ;
          titlestr = ['Block X, V Singly Joint Mode of Variation ' ...
                           num2str(iSVJmodefig)] ;
          paramstruct = struct('icolor',2, ...
                               'icolordist',0, ...
                               'titlestr',titlestr) ;
          HeatMapSM(mSVJmode_X,paramstruct) ;

        subplot(1,2,2) ;
          titlestr = ['Block Y, V Singly Joint Mode of Variation ' ...
                           num2str(iSVJmodefig)] ;
          paramstruct = struct('icolor',2, ...
                               'icolordist',0, ...
                               'titlestr',titlestr) ;
          HeatMapSM(mSVJmode_Y,paramstruct) ;

        if ~isempty(DiagPlotStr) 
          savestr = [DiagPlotStr 'SVJmode' num2str(iSVJmodefig)] ;
          printSM(savestr,savetype) ;
        end

      end     %  of iDiagPlot == 1  if-block


    elseif imodetype == 4     %  Found X Individual Mode

      if iscreenwrite == 1
        disp('Found X Individual Mode of Variation') ;
      end

      %  Update running quantities
      %
      mE_X = mE_X - mImode_X ;
      mA_X = mA_X + mImode_X ;
          %  Running matrices
      nmodes = nmodes + 1 ;
          %  number of modes of variation found so far
      caXmodes(nmodes,1) = {'I'} ;
      caXmodes(nmodes,2) = {vlam_X(1)} ;
      caXmodes(nmodes,3) = {mU_X(:,1)} ;
      caXmodes(nmodes,4) = {mV_X(:,1)} ;
          %  cell arrays of significant modes of variation


      if iDiagPlot == 1     %  Plot X Individual Mode of variation

        iImodefig = iImodefig + 1 ;
        fh5 = figure('WindowStyle','normal') ;
        clf ;
        set(fh5,'Position',[100 100 1000 550]) ;

        subplot(1,2,1) ;
          titlestr = ['Block X, Individual Mode of Variation ' ...
                           num2str(iImodefig)] ;
          paramstruct = struct('icolor',2, ...
                               'icolordist',0, ...
                               'titlestr',titlestr) ;
          HeatMapSM(mImode_X,paramstruct) ;

        subplot(1,2,2) ;
          title(['Block Y, Individual Mode of Variation ' ...
                           num2str(iImodefig)]) ;

        if ~isempty(DiagPlotStr)
          savestr = [DiagPlotStr 'Imode' num2str(iImodefig)] ;
          printSM(savestr,savetype) ;
        end

      end     %  of iDiagPlot == 1  if-block


    elseif imodetype == 5     %  Found Y Individual Mode

      if iscreenwrite == 1
        disp('Found Y Individual Mode of Variation') ;
      end

      %  Update running quantities
      %
      mE_Y = mE_Y - mImode_Y ;
      mA_Y = mA_Y + mImode_Y ;
          %  Running matrices
      nmodes = nmodes + 1 ;
          %  number of modes of variation found so far
      caYmodes(nmodes,5) = {'I'} ;
      caYmodes(nmodes,6) = {vlam_Y(1)} ;
      caYmodes(nmodes,7) = {mU_Y(:,1)} ;
      caYmodes(nmodes,8) = {mV_Y(:,1)} ;
          %  cell arrays of significant modes of variation


      if iDiagPlot == 1     %  Plot Y Individual Mode of variation

        iImodefig = iImodefig + 1 ;
        fh6 = figure('WindowStyle','normal') ;
        clf ;
        set(fh6,'Position',[100 100 1000 550]) ;

        subplot(1,2,1) ;
          title(['Block X, Individual Mode of Variation ' ...
                           num2str(iImodefig)]) ;

        subplot(1,2,2) ;
          titlestr = ['Block Y, Individual Mode of Variation ' ...
                           num2str(iImodefig)] ;
          paramstruct = struct('icolor',2, ...
                               'icolordist',0, ...
                               'titlestr',titlestr) ;
          HeatMapSM(mImode_Y,paramstruct) ;

        if ~isempty(DiagPlotStr)
          savestr = [DiagPlotStr 'Imode' num2str(iImodefig)] ;
          printSM(savestr,savetype) ;
        end

      end     %  of iDiagPlot == 1  if-block


    end     %  of imodetype if-block


  end     %  of main loop, stepping through components


  outstruct.caXmodes = caXmodes ;
  outstruct.caYmodes = caYmodes ;

  if iDiagPlot == 1
    if ~isempty(DiagPlotStr)
      %  Print diagnostic plots
      %
      figure(fh1) ;
      disp('Somehow need this pause to print proper diagnostic plot') ;
      pauseSM
      savestr = [DiagPlotStr 'SVdiagnostic'] ;
      printSM(savestr,savetype) ;
    end
  end      %  of iDiagPlot i f-block

  if iscreenwrite == 1
    disp(' ') ;
    disp(' ') ;
  end 


elseif imptype == 2     %  QZ based implementation
                        %      from DoublyJointToy9.m


  outstruct = 'Not defined yet' ;


else ;

  disp('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!') ;
  disp('!!!   Error from DIVASDoubJointSM   !!!') ;
  disp('!!!   Invalid value of imptype      !!!') ;
  disp('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!') ;

end     %  of imptype if-block


